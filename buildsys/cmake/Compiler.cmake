
ADD_DEFINITIONS(-DUNICODE -D_UNICODE)


# find_package(LLVM REQUIRED CONFIG)

IF(CMAKE_C_COMPILER_ID MATCHES Clang)
ELSE()
    MESSAGE(FATAL_ERROR "Only LLVM/Clang support")
ENDIF()

SET(LOO_COMPILER_NAME "clang")

IF(LOO_PLATFORM_WINDOWS)
    SET(LOO_COMPILER_CLANGC2 TRUE)
    MESSAGE("LOO_COMPILER_CLANGC2=${LOO_COMPILER_CLANGC2}")
ENDIF()
MESSAGE("CMAKE_C_COMPILER=${CMAKE_C_COMPILER}")
#EXECUTE_PROCESS(COMMAND ${CMAKE_C_COMPILER} --version OUTPUT_VARIABLE CLANG_VERSION)
SET(CLANG_VERSION ${CMAKE_CXX_COMPILER_VERSION})
MESSAGE("CLANG_VERSION=${CLANG_VERSION}")
STRING(REGEX MATCHALL "[0-9]+" CLANG_VERSION_COMPONENTS ${CLANG_VERSION})
LIST(GET CLANG_VERSION_COMPONENTS 0 CLANG_MAJOR)
LIST(GET CLANG_VERSION_COMPONENTS 1 CLANG_MINOR)
SET(LOO_COMPILER_VERSION ${CLANG_MAJOR}${CLANG_MINOR})

IF(NOT LOO_COMPILER_CLANGC2)
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -W -Wall -Werror -fPIC")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -W -Wall -Werror -fPIC")
ENDIF()
IF(NOT (ANDROID OR IOS))
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -march=core2 -msse2")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=core2 -msse2")
ENDIF()

SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11")
SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")

IF((NOT MSVC) AND LOO_PLATFORM_WINDOWS)
ADD_DEFINITIONS(-D_WIN32_WINNT=0x0601 -DWINVER=_WIN32_WINNT)
ENDIF()

SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DDEBUG -O0  -g")
SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -DNDEBUG -O2 -DLOO_SHIP")
SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -DNDEBUG -g -O2")
SET(CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} -DNDEBUG -Os")

IF(LOO_ARCH_NAME STREQUAL "x86")
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m32")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32")
    IF(NOT MSVC)
        SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -m32")
        SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -m32")
        SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -m32")
        IF(LOO_PLATFORM_WINDOWS)
            SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--large-address-aware")
            SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -Wl,--large-address-aware")
            SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--large-address-aware")

            SET(CMAKE_RC_FLAGS "${CMAKE_RC_FLAGS} --target=pe-i386")
        ELSE()
            SET(CMAKE_RC_FLAGS "${CMAKE_RC_FLAGS} --target=elf32-i386")
        ENDIF()
    ENDIF()
ELSEIF((LOO_ARCH_NAME STREQUAL "x64") OR (LOO_ARCH_NAME STREQUAL "x86_64"))
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m64")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m64")
    IF(NOT MSVC)
        SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -m64")
        SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -m64")
        SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -m64")
        IF(LOO_PLATFORM_WINDOWS)
            SET(CMAKE_RC_FLAGS "${CMAKE_RC_FLAGS} --target=pe-x86-64")
        ELSE()
            SET(CMAKE_RC_FLAGS "${CMAKE_RC_FLAGS} --target=elf64-x86-64")
        ENDIF()
    ENDIF()
ENDIF()
IF(NOT MSVC)
    SET(CMAKE_SHARED_LINKER_FLAGS_RELEASE "-s")
    SET(CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL "-s")
    SET(CMAKE_MODULE_LINKER_FLAGS_RELEASE "-s")
    SET(CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL "-s")
    SET(CMAKE_EXE_LINKER_FLAGS_RELEASE "-s")
    SET(CMAKE_EXE_LINKER_FLAGS_MINSIZEREL "-s")
ENDIF()

SET(CMAKE_C_FLAGS_DEBUG ${CMAKE_CXX_FLAGS_DEBUG})
SET(CMAKE_C_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
SET(CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO})
SET(CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_MINSIZEREL})

# open rtti in debug mode
#SET(RTTI_FLAG "-frtti")
IF(LOO_COMPILER_CLANGC2)
    SET(NO_RTTI_FLAG "")
ELSE()
    SET(NO_RTTI_FLAG "-fno-rtti")
ENDIF()

SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} ${RTTI_FLAG}")
SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} ${NO_RTTI_FLAG}")
SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${NO_RTTI_FLAG}")
SET(CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} ${NO_RTTI_FLAG}")

IF(LOO_PLATFORM_ANDROID)
	SET(ANDROID_API_DEFINITION "-D__ANDROID_API__=${ANDROID_NATIVE_API_LEVEL}")
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ANDROID_API_DEFINITION}")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ANDROID_API_DEFINITION}")

	# TODO: Figure out why LINK_DIRECTORIES doesn't work for ${ANDROID_STL_LIBRARY_DIRS}
	SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -L${ANDROID_STL_LIBRARY_DIRS}")
ENDIF()


SET(LOO_OUTPUT_SUFFIX _${LOO_COMPILER_NAME}${LOO_COMPILER_VERSION})

IF(LOO_BUILD_SHARED)
    ADD_DEFINITIONS(-DLOO_SHARED)
ELSE()
    ADD_DEFINITIONS(-DLOO_STATIC)
ENDIF()

IF(MSVC)
	# create vcproj.user file for Visual Studio to set debug working directory
	FUNCTION(CREATE_VCPROJ_USERFILE TARGETNAME)
		SET(SYSTEM_NAME $ENV{USERDOMAIN})
		SET(USER_NAME $ENV{USERNAME})

		CONFIGURE_FILE(
			${LOO_ROOT_DIR}/buildsys/cmake/VisualStudio2010UserFile.vcxproj.user.in
			${CMAKE_CURRENT_BINARY_DIR}/${TARGETNAME}.vcxproj.user
			@ONLY
		)
	ENDFUNCTION()
ENDIF()
IF(LOO_PLATFORM_DARWIN OR LOO_PLATFORM_IOS)
	# create .xcscheme file for Xcode to set debug working directory
	FUNCTION(CREATE_XCODE_USERFILE PROJECTNAME TARGETNAME)
		IF(LOO_PLATFORM_DARWIN OR LOO_PLATFORM_IOS)
			SET(SYSTEM_NAME $ENV{USERDOMAIN})
			SET(USER_NAME $ENV{USER})

			CONFIGURE_FILE(
				${LOO_ROOT_DIR}/buildsys/cmake/xcode.xcscheme.in
				${PROJECT_BINARY_DIR}/${PROJECTNAME}.xcodeproj/xcuserdata/${USER_NAME}.xcuserdatad/xcschemes/${TARGETNAME}.xcscheme
				@ONLY
			)
		ENDIF()
	ENDFUNCTION()
ENDIF()
	
FUNCTION(CREATE_PROJECT_USERFILE PROJECTNAME TARGETNAME)
	IF(MSVC)
		CREATE_VCPROJ_USERFILE(${TARGETNAME})
	ELSEIF(LOO_PLATFORM_DARWIN OR LOO_PLATFORM_IOS)
		CREATE_XCODE_USERFILE(${PROJECTNAME} ${TARGETNAME})
	ENDIF()
ENDFUNCTION()

# set(PUBLIC_LIBS ${PUBLIC_LIBS})
# #if use llvm tools
# include_directories(${LLVM_INCLUDE_DIRS})
# add_definitions(${LLVM_DEFINITIONS})
# # Find the libraries that correspond to the LLVM components
# # that we wish to use
# # Core
# # ExecutionEngine
# # Interpreter
# # MC
# # Support
# # nativecodegen
# # irreader
# set（LLVM_LINK_COMPONENTS
#     Core
#     Support
#     )
# llvm_map_components_to_libnames(llvm_libs ${set（LLVM_LINK_COMPONENTS})
# # Link against LLVM libraries
# #target_link_libraries(llvm_test  ${llvm_libs})
# set(PUBLIC_LIBS ${PUBLIC_LIBS})
